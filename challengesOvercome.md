### [Back to Portfolio](index.md)

### [Back to Table of Contents](seniorproject.md)

### [View Full Report Here](fullReport.md)

Challenges Overcome
====================
There were several challenges that I had to over come for this project including:

1. During the initial development I had completed the first two sets of steps on the Implementation schedule and suffered a data failure from a MacOS update. Prior to this happening I did not upload the project to a github repository nor did I have it on another drive. So the only copy was lost to the drive that had crashed. This meant that I had to recreate the entire project that I had made which was difficult since I did not have a backup anywhere. Additionally, this means that the current state of the project is not the same as it was before this hard drive crash. After recreating what I had lost in the crash I began keeping updated versions on additional drives and on a Github repository.
2. I had run into an issue with creating files while trying to store the encrypted and decrypted text. The files that were generated would default save to the actual project folder created by NetBeans when setting up the project initially. This was not where I wanted the files to be saved to so I had to make a workaround that allowed me to point to a specific folder, the Desktop, where I wanted the files to be saved.
3. Once getting the files to save to the desktop was achieved I had another problem identifying which files were created first and the corresponding decryption files was difficult. So I created a segment within the same section that directs the files to the desktop that names each folder one number higher than the previous recorded file. By default it always starts a xEncryption1 or xDecryption1, and adds one to a iterator and checks to see if that file name exists if it does then it adds one again until it finds an unused filename. This also means that since its searching that the encryption and decryption pairs can be identified easier since they will have the same digit assigned to their respective files. This is because when dividing the encryption and decryption each type has their own filename so Caesarean is CaesarEncryption and CaesarDecryption.
4. With DES I ran into an issue when trying to setup the recursive property for multiple-file use in one program instance. The issue was that since the Secret Key was not being saved it was impossible to decrypt the file after encrypting. This was because I was unknowingly using two instances for the encryption and decryption and since there were two instances the two secret keys were different and would not match therefore there was no decryption occuring. The current workaround that I put in is that once it encrypts the file it starts the decryption process. The user will still have to pass a verification before having the program decrypt the file but the encryption and decryption must be done at the same time otherwise it currently can not be decrypted otherwise.
